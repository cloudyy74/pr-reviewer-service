# pr-reviewer-service

Сервис для автоматического назначения ревьюеров на Pull Request’ы, управления командами и участниками, а также получения информации о назначенных ревью.

## Решение

- Реализованы все эндпоинты из `api/openapi.yml`: создание/получение команд, управление активностью пользователей, создание/merge/переназначение PR и выдача списка ревью для пользователя
- По условию неясно, может пользователь быть в нескольких командах одновременно или нет. Я решил что будет логичнее, если каждый пользователь будет только в одной команде
- Добавлен дополнительный эндпоинт статистики `GET /stats/assignments`, возвращающий количество назначений по пользователям и по PR
- Реализован эндпоинт деактивации команды `POST /team/deactivate`
- Настроены миграции PostgreSQL и автоматический запуск сервисов через `docker-compose`. Для интеграционных тестов используется отдельный compose (`docker-compose.test.yml`) + миграции
- Покрытие тестами:
  - unit (sqlmock для storage, сервисы, http-хендлеры)
  - интеграционные - используют реальную БД, создают команды/PR/переназначения и проверяют e2e сценарии.
- Произведено нагрузочное тестирование (отчёт ниже)
- Все критичные места SQL-запросов покрыты индексами
- Описана конфигурация линтера в `/.golangci.yml`
- Реализован CI c помощью GitHub Actions, прогоняющий линтер и юнит-тесты

## Конфигурация

Базовая конфигурация для запуска в `Docker` (`/config/docker.yml`)

```yaml
env: "local"
db_url: "postgres://postgres:postgres@db:5432/pr-reviewer-db"
http_server:
  addr: "0.0.0.0:8080"
  timeout: 4s
  idle_timeout: 60s
```

## Инструкция по запуску

### Требования

Необходимо чтобы был установлен `Docker` и `docker-compose`

### Запуск

0. Вы можете отредактировать `.env`, лежащий в репозитории, его структура:

```dotenv
POSTGRES_DB=...
POSTGRES_USER=...
POSTGRES_PASSWORD=...
CONFIG_PATH=...
```

1. Запуск контейнера с приложением и всем необходимым окружением:

```commandline
make compose-up

## or just

docker-compose up
```

2. Остановка

```commandline
make compose-down

## or just

docker-compose down
```

### Запуск тестов

Подготовлен `docker-compose.test.yml` для запуска сразу и юнит, и интеграционных тестов.

1. Запуск

```commandline
make compose-test-up
```

2. Остановка

```commandline
make compose-test-down
```

### Другие команды Makefile

```commandline
make run   // запускает проект локально
make test  // прогоняет тесты локально

make lint  // прогоняет линтер
make fmt   // прогоняет форматер и сортировку импортов
```

## Отчет о нагрузочном тестировании

Для нагрузочного тестирования использовался простенький скрипт на js (grafana/k6). Использовалось RPS - 5, 20 команд и 200 пользователей.

Запуск из папки `/scripts` (если приложение запщуено в `Docker`, иначе добавить переменную окружения `BASE_URL`):

```commandline
docker run --rm -i \
  -v $PWD/load_test.js:/scripts/load_test.js \
  grafana/k6 run /scripts/load_test.js
```

Полученные результаты:

```commandline
HTTP
    http_req_duration..............: avg=6.49ms   min=1.3ms    med=2.9ms    max=90.64ms  p(90)=16.16ms p(95)=16.75ms
      { expected_response:true }...: avg=6.49ms   min=1.3ms    med=2.9ms    max=90.64ms  p(90)=16.16ms p(95)=16.75ms
    http_req_failed................: 0.00%  0 out of 6020
    http_reqs......................: 6020   20.05625/s
```

Как видно, решение укладывается в SLI времени ответа (300 ms) и успешности (99.9%) с большим запасом.

## Использующийся стек

- Go 1.25
- PostgreSQL
- golang-migrate
- Docker, docker-compose
- k6

## Структура проекта

- `/api` - описание API
- `/cmd/pr-reviewer-service` - точка входа в приложение
- `/config` - конфиг файлы в формате `yaml`
- `/internal/app` - инициализация приложения, создание сервиса, слоя работы с данными и `http` сервера
- `/internal/config` - чтения конфига из `/config`
- `/internal/data` - миграции
- `/internal/models` - модели
- `/internal/http` - middleware, хэндлеры, которые обрабатывают все эндпоинты
- `/pkg` - код, который можно переиспользовать в других проектах (подключение к бд `postgres`)
- `/internal/service` - сервисная логика
- `/internal/storage` - логика для работы с бд
- `/scripts` - вспомогательные скрипты (нагрузочное тестирование)
- `/integration-test` - интеграционные e2e тесты
